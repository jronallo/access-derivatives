#!/usr/bin/env ruby

# Script that queries Sal for all Technician newspapers and
# creates OCR for each page and then combined resources for
# each resource.

require 'fileutils'
require 'tempfile'
require 'iiif_url'
require 'httpclient'
require 'json'
require 'nokogiri'

lock_file_name = '/tmp/process_technician_ocr.lock'
IiifUrl.set_base_url("https://iiif.lib.ncsu.edu/iiif")

# If the lock file does not exist we create it.
unless File.exist?(lock_file_name)
  FileUtils.touch(lock_file_name)
end

# Unless we get a lock on the lockfile we exit immediately.
# We keep a file handle open so that we retain the lock the whole time.
flock_file = File.open(lock_file_name, 'w')
unless flock_file.flock(File::LOCK_NB|File::LOCK_EX)
  puts "Can't get lock so exiting! No OCR processed."
  exit
end

# set up some paths
@ocr_directory = "/access-images/ocr/"
@http_client = HTTPClient.new

# Make the request to Sal for the results for the page
def get_technician_results_for_page(page: 1)
  url = "http://d.lib.ncsu.edu/collections/catalog.json?f[ispartof_facet][]=Technician&per_page=10&page=#{page}"
  response = @http_client.get url
  json = response.body
  JSON.parse json
end

# Based on a identifier determine if all the OCR files already exist
def ocr_already_exists?(identifier)
  File.size?(txt_filepath(identifier)) && File.size?(hocr_filepath(identifier)) && File.size?(pdf_filepath(identifier))
end

def output_base_filepath(identifier)
  File.join directory_for_identifier(identifier), identifier
end

def txt_filepath(identifier)
  output_base_filepath(identifier) + '.txt'
end

def hocr_filepath(identifier)
  output_base_filepath(identifier) + '.hocr'
end

def pdf_filepath(identifier)
  output_base_filepath(identifier) + '.pdf'
end

def json_file_filepath(identifier)
  output_base_filepath(identifier) + '.json'
end

def directory_for_first_two(identifier)
  first_two_of_identifier = identifier.slice(0, 2)
  File.join @ocr_directory, first_two_of_identifier
end

def directory_for_identifier(identifier)
  File.join directory_for_first_two(identifier), identifier
end

def parse_hocr_title(title)
  parts = title.split(';').map(&:strip)
  info = {}
  parts.each do |part|
    sections = part.split(' ')
    sections.shift
    if /^bbox/.match(part)
      info['x0'], info['y0'], info['x1'], info['y1'] = sections
    elsif /^x_wconf/.match(part)
      info['c'] = sections.first
    end
  end
  info
end

def create_word_boundary_json(identifier)
  # json_file_filepath(identifier)
  doc = File.open(hocr_filepath(identifier)) { |f| Nokogiri::HTML(f) }
  json = {}
  doc.css('span.ocrx_word').each do |span|
    word = span.text
    json[word] ||= []
    title = span['title']
    info = parse_hocr_title(title)
    json[word] << info
  end
  File.open(json_file_filepath(identifier), 'w') do |fh|
    fh.puts json.to_json
  end
end

# Given a doc iterate over each of the jp2s and process OCR for them
def process_ocr_for_each_page(doc)
  doc['jp2_filenames_sms'].each do |identifier|
    puts identifier

    # TODO: allow turning this feature off via CLI
    if ocr_already_exists?(identifier)
      puts "OCR already exists. Skipping #{identifier}"
      next
    end

    # create tempfile for image
    tmp_png = Tempfile.new([identifier, '.png'])
    # IIIF URL
    url = IiifUrl.from_params identifier: identifier, format: 'png'
    # get image with httpclient
    response = @http_client.get url
    # write image to tempfile
    tmp_png.puts response.body
    # create directory to put tesseract outputs
    tesseract_output_directory = directory_for_identifier(identifier)
    FileUtils.mkdir_p tesseract_output_directory
    # chanage to directory to put tesseract outputs
    Dir.chdir tesseract_output_directory
    # create outputs (txt, hOCR, PDF) with tesseract.
    # Look under /usr/share/tesseract/tessdata/configs/ to see hocr and pdf values.
    `tesseract #{tmp_png.path} #{identifier} -l eng hocr pdf`

    # Do a check that the files were properly created
    if ocr_already_exists?(identifier)
      # extract words and boundaries from hOCR into a JSON file
      create_word_boundary_json(identifier)
      # Set permissions
      FileUtils.chmod_R('ug=rwX,o=rX', directory_for_first_two(identifier))
    else
      # remove them if they don't exist
      FileUtils.rm_rf directory_for_identifier(identifier)
    end

    # remove the temporary file
    tmp_png.close
    tmp_png.unlink
  end
end

def concatenate_txt(doc)
  #code
end

# Given a doc
def concatenate_ocr_for_resource(doc)
  # TODO: concatenate txt
  concatenate_txt(doc)
  # TODO: concatenate PDFs
  # TODO: concatenate hOCR
end

# get the first page of results to find total_pages
response = get_technician_results_for_page
total_pages = response['response']['pages']['total_pages']

# Yes, there's a duplicate request for the first page here, but this is a bit
# simpler.
total_pages.times do |page|
  response = get_technician_results_for_page(page: page)
  response['response']['docs'].each do |doc|
    # A doc is a resource and can have multiple pages
    process_ocr_for_each_page(doc)
    concatenate_ocr_for_resource(doc)
    #TODO: allow this to run over all Technicians
    exit
  end
end

# unlock the file
flock_file.flock(File::LOCK_UN)
